import claripy
#from pwn import *

#USE nc bin.training.jinblack.it 2020
#to test it online and find the flag

#the program generates 1000 random values and we want the 1001 value
#not using angr is better in this case. We can use z3 without angr
#Alternative solution: you can brute force it. It should take less than 1 hour in average (a lot less if we are lucky).

#This version is not working need to be fixed.

s = claripy.Solver()

mag3808 = [0x0, 0x9908b0DF]

def mag (i):
	return claripy.If(i == 0, claripy.BVV(mag3808[0],33), claripy.BVV(mag3808[1],33))

#state initialization to something
#state_state = [0]*0x300 we use the class construct instead
class State:
	def __init__(self):
		self.state=[0]*0x270
		self.index=0


#function taken from ghidra and converted to python manually
def m_seedRand(state, seed):
	state.state[0] = seed & 0xffffffff # setting a mask
	state.index = 1
	while (state.index < 0x270):
		state.state[state.index] = (state.state[state.index -1] * 0x17b5) & 0xffffffff
		state.index = state.index + 1
	return state


def genRandLong(state):
	if (0x26f < state.index or state.index < 0):
		if (0x270 < state.index or state.index < 0):
			m_seedRand(state,0x1105)
		
		for index in range(0xe3):
			part1 = state.state[index + 0x18d]
			part2 = ((state.state[index + 1] & 0x7fffffff) | (state.state[index] & 0x80000000)) >> 1
			part3 = mag(state.state[index + 1] & 1)
			state.state[index] = (part1 ^ part2 ^ part3) & 0x7fffffff
		
		for index in range(0x26f):
			part1 = state.state[index - 0xe3]
			part2 = ((state.state[index + 1] & 0x7fffffff) | (state.state[index] & 0x80000000)) >> 1
			part3 = mag(state.state[index + 1] & 1)
			state.state[index] = ( part1 ^ part2 ^ part3) & 0x7fffffff
		
		part1 = state.state[0x18c]
		part2 = ((state.state[0] & 0x7fffffff) | (state.state[0x26f] & 0x80000000)) >> 1
		part3 = mag(state.state[0] & 1)
		state.state[0x26f] = (part1 ^ part2 ^ part3) & 0x7fffffff
		state.index = 0
	iVar1 = state.index
	state.index = iVar1 + 1
	uVar2 = (state.state[iVar1] ^ (state.state[iVar1] >> 0xb)) & 0xffffffff
	uVar2 = (uVar2 ^ (uVar2 << 7) & 0x9d2c5680) & 0xffffffff
	uVar2 = (uVar2 ^ (uVar2 << 0xf) & 0xefc60000) & 0xffffffff
	return (uVar2 ^ (uVar2 >> 0x12)) & 0xffffffff

seed = claripy.BVS('seed', 33) #symbolic value BVS (BVV for concrete value)
state = State() #calling the class
state = m_seedRand(state, seed)
for i in range(0,1000):
	genRandLong(state)

res = genRandLong(state) #symbolic value

random_value = 0xfa4672dd
s.add(res == random_value)

final_value = s.eval(seed, 1)
print(final_value)

#import IPython
#IPython.embed() #look at seed and at state (call them in ipython exactly seed and state)

